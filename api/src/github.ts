/**
 * GitHub REST API: create repository for an implementation module.
 * Orchestrator creates repo; Modal (or implementation) pushes code.
 */

import { log } from "./logger.ts";

const GITHUB_API = "https://api.github.com";

export interface CreateRepoResult {
  cloneUrl: string;
  htmlUrl: string;
  fullName: string;
}

export async function createRepo(name: string): Promise<CreateRepoResult> {
  const token = process.env.GITHUB_TOKEN;
  if (!token) {
    log.error("GITHUB_TOKEN not set");
    throw new Error("GITHUB_TOKEN required");
  }

  log.github("Creating repo " + name + " ...");
  const res = await fetch(`${GITHUB_API}/user/repos`, {
    method: "POST",
    headers: {
      Accept: "application/vnd.github+json",
      Authorization: `Bearer ${token}`,
      "X-GitHub-Api-Version": "2022-11-28",
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      name: name,
      private: false,
      description: "Generated by Epoch",
      auto_init: true,
    }),
  });

  if (!res.ok) {
    const text = await res.text();
    log.error("Create repo failed: " + res.status + " " + text);
    throw new Error(`GitHub create repo failed: ${res.status}`);
  }

  const data = (await res.json()) as { clone_url?: string; html_url?: string; full_name?: string };
  const cloneUrl = data.clone_url ?? "";
  const htmlUrl = data.html_url ?? "";

  const fullName = data.full_name ?? name;
  log.github("Repo created: " + fullName + " " + cloneUrl);
  return { cloneUrl, htmlUrl, fullName };
} 

/**
 * Create a branch in the repo (from default branch tip). Used so Vercel can deploy the branch as soon as it exists.
 */
export async function createBranch(repoFullName: string, branchName: string): Promise<void> {
  const token = process.env.GITHUB_TOKEN;
  if (!token) {
    log.error("GITHUB_TOKEN not set");
    throw new Error("GITHUB_TOKEN required");
  }

  log.github("Creating branch " + branchName + " in " + repoFullName + " ...");
  const repoRes = await fetch(`https://api.github.com/repos/${repoFullName}`, {
    headers: {
      Accept: "application/vnd.github+json",
      Authorization: `Bearer ${token}`,
      "X-GitHub-Api-Version": "2022-11-28",
    },
  });
  if (!repoRes.ok) {
    const text = await repoRes.text();
    log.error("Get repo failed: " + repoRes.status + " " + text);
    throw new Error(`GitHub get repo failed: ${repoRes.status}`);
  }
  const repoData = (await repoRes.json()) as { default_branch?: string };
  const defaultBranch = repoData.default_branch ?? "main";

  const refRes = await fetch(
    `https://api.github.com/repos/${repoFullName}/git/refs/heads/${defaultBranch}`,
    {
      headers: {
        Accept: "application/vnd.github+json",
        Authorization: `Bearer ${token}`,
        "X-GitHub-Api-Version": "2022-11-28",
      },
    }
  );
  if (!refRes.ok) {
    const text = await refRes.text();
    log.error("Get ref failed: " + refRes.status + " " + text);
    throw new Error(`GitHub get ref failed: ${refRes.status}`);
  }
  const refData = (await refRes.json()) as { object?: { sha?: string } };
  const sha = refData.object?.sha;
  if (!sha) {
    log.error("No SHA in ref response");
    throw new Error("GitHub ref has no SHA");
  }

  const createRefRes = await fetch(`https://api.github.com/repos/${repoFullName}/git/refs`, {
    method: "POST",
    headers: {
      Accept: "application/vnd.github+json",
      Authorization: `Bearer ${token}`,
      "X-GitHub-Api-Version": "2022-11-28",
      "Content-Type": "application/json",
    },
    body: JSON.stringify({ ref: `refs/heads/${branchName}`, sha }),
  });
  if (!createRefRes.ok) {
    const text = await createRefRes.text();
    log.error("Create branch failed: " + createRefRes.status + " " + text);
    throw new Error(`GitHub create branch failed: ${createRefRes.status}`);
  }
  log.github("Branch created: " + branchName);
}

export function parseRepoFullName(repoUrl: string): [string, string] {
  const m = repoUrl.match(/github\.com[/:]([^/]+)\/([^/]+?)(?:\.git)?$/);
  if (m) return [m[1]!, m[2]!.replace(/\.git$/, "")];
  return ["", ""];
}
